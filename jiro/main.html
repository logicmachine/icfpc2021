<!DOCTYPE html>
<html lang="ja">
    <head>
        <style>
          canvas {
            position: absolute;
          }
        </style>
        <title>Sample</title>
    </head>
    <body>
        <div id="container"></div>
        <canvas id="canvas" style="z-index:1"></canvas>
        <canvas id="overlay" width="800" height="600" style="z-index:2; pointer-events: none;"></canvas>
        <script src="./js/matter.min.js"></script>
        <script>
          let dist = function(xy1, xy2){
            return (xy1.x - xy2.x) * (xy1.x - xy2.x) + (xy1.y - xy2.y) * (xy1.y - xy2.y)
          }
          const x_origin = 100
          const y_origin = 100
          const x_scale = 10
          const y_scale = x_scale
          const width = 800
          const height = 600
          let eps
          let constraint_dists = []
          func = function(input) {
              var Engine = Matter.Engine,
                  Render = Matter.Render,
                  Runner = Matter.Runner,
                  Composites = Matter.Composites,
                  Common = Matter.Common,
                  Constraint = Matter.Constraint,
                  MouseConstraint = Matter.MouseConstraint,
                  Mouse = Matter.Mouse,
                  Composite = Matter.Composite,
                  Bodies = Matter.Bodies;

              // create engine
              var engine = Engine.create(),
                  world = engine.world;
              engine.world.gravity.y = 0;

              var canvas = document.getElementById('canvas')
              var overlay = document.getElementById('overlay')

              // create renderer
              render = Render.create({
                  element: document.body,
                  engine: engine,
                  canvas: canvas,
                  options: {
                      width: width,
                      height: height,
                      wireframes: false,
                      showAngleIndicator: true,
                      background: '#aaaaaa'
                  }
              });

              Render.run(render);

              // create runner
              var runner = Runner.create();
              Runner.run(runner, engine);

              holes = input.hole.slice()
              holes.push(holes[0])
              H = []
              for(let i = 0; i < holes.length-1; i++){
                x1 = holes[i][0] * x_scale + x_origin
                y1 = holes[i][1] * y_scale  + y_origin
                x2 = holes[i+1][0] * x_scale  + x_origin
                y2 = holes[i+1][1] * y_scale  + y_origin
                xc = (x1 + x2) / 2
                yc = (y1 + y2) / 2
                len = Math.sqrt((x2-x1) * (x2-x1) + (y2-y1) * (y2-y1))
                angle = Math.PI / 2
                if(x2 != x1){
                  angle = Math.atan((y2 - y1) / (x2 - x1))
                  if(x2 < x1){
                    angle += Math.PI
                  }
                }
                hole_line_width = 10
                let body = Bodies.rectangle(xc,yc,len,hole_line_width, {isStatic: true, angle: angle, density:1})
                dy = -(x2 - x1) / len
                dx = (y2 - y1) / len
                // Matter.Body.translate(body, {x:0, y:100})
                Matter.Body.translate(body, {x:hole_line_width/2 * dx, y:hole_line_width/2 * dy})
                Composite.add(world,[
                  body
                ]);
                H.push(body)
                body['pointer-event'] = 'none'
              }

              vertices = input.figure.vertices.slice()
              edges = input.figure.edges.slice()
              V = []
              E = []
              for(let i = 0; i < vertices.length; i++){
                const x = vertices[i][0] * x_scale + x_origin
                const y = vertices[i][1] * y_scale + y_origin
                const r = 4
                const v = Bodies.circle(x, y, r, {frictionAir: 1, inertia: Infinity, render:{fillStyle:'white', strokeStyle:'white'}})
                V.push(v)
              }
              for(let i = 0; i < edges.length; i++){
                const idx1 = edges[i][0]
                const idx2 = edges[i][1]
                const v1 = V[idx1]
                const v2 = V[idx2]
                constraint = Constraint.create({
                  bodyA: v1,
                  pointA: {x:0, y:0},
                  bodyB: v2,
                  pointB: {x:0, y:0},
                  render:{
                    lineWidth: 1,
                  },
                  stiffness: 0.001
                });
                E.push(constraint)
                constraint_dists.push(dist(v1.position, v2.position))
              }

              Composite.add(world, V);
              Composite.add(world, E);

              eps = input.epsilon

              Composite.add(world, [
                  // walls
                  Bodies.rectangle(400, 0, 800, 50, { isStatic: true }),
                  Bodies.rectangle(400, 600, 800, 50, { isStatic: true }),
                  Bodies.rectangle(800, 300, 50, 600, { isStatic: true }),
                  Bodies.rectangle(0, 300, 50, 600, { isStatic: true })
              ]);

              // add mouse control
              mouse = Mouse.create(render.canvas),
                  mouseConstraint = MouseConstraint.create(engine, {
                      mouse: mouse,
                      constraint: {
                          // allow bodies on mouse to rotate
                          angularStiffness: 0,
                          render: {
                              visible: false
                          }
                      }
                  });

              Composite.add(world, mouseConstraint);

              // keep the mouse in sync with rendering
              render.mouse = mouse;

              // fit the render viewport to the scene
              Render.lookAt(render, {
                  min: { x: 0, y: 0 },
                  max: { x: 800, y: 600 }
              });

              //grid線を書く
              let context = overlay.getContext('2d')
              context.linewidth = 1;
              for(let i = 0; i < height; i+=y_scale){
                context.beginPath();
                context.moveTo(0,i);
                context.lineTo(width,i);
                context.closePath();
                context.stroke();
              }
              for(let j = 0; j < width; j+=x_scale){
                context.beginPath();
                context.moveTo(j,0);
                context.lineTo(j,height);
                context.closePath();
                context.stroke();
              }

              // context for MatterTools.Demo
              return {
                  engine: engine,
                  runner: runner,
                  render: render,
                  canvas: render.canvas,
                  stop: function() {
                      Matter.Render.stop(render);
                      Matter.Runner.stop(runner);
                  }
              };
          };
          input = {"hole":[[45,80],[35,95],[5,95],[35,50],[5,5],[35,5],[95,95],[65,95],[55,80]],"epsilon":150000,"figure":{"edges":[[2,5],[5,4],[4,1],[1,0],[0,8],[8,3],[3,7],[7,11],[11,13],[13,12],[12,18],[18,19],[19,14],[14,15],[15,17],[17,16],[16,10],[10,6],[6,2],[8,12],[7,9],[9,3],[8,9],[9,12],[13,9],[9,11],[4,8],[12,14],[5,10],[10,15]],"vertices":[[20,30],[20,40],[30,95],[40,15],[40,35],[40,65],[40,95],[45,5],[45,25],[50,15],[50,70],[55,5],[55,25],[60,15],[60,35],[60,65],[60,95],[70,95],[80,30],[80,40]]}}

          func(input);
          document.addEventListener("copy", function(e){
              let ans = ""
              for(let i = 0; i < V.length; i++){
                let x = V[i].position.x
                let y = V[i].position.y
                x -= x_origin
                y -= y_origin
                x /= x_scale
                y /= y_scale
                ans += x + " " + y + "\n"
              }
              e.clipboardData.setData("text/plain" , ans);    
              // 本来のイベントをキャンセル
              e.preventDefault();
              alert("各点の座標をコピーしました")
          });
          document.onkeydown = function(e) {
              let move_ok
              if(e.keyCode == 65){//a
                move_ok = true
                console.log("active")
              }else if(e.keyCode == 83){//s
                move_ok = false;
                console.log("stop")
              }else{
                console.log(e.keyCode)
                return
              }
              e.preventDefault();//規定の動作をキャンセル
              let x1 = mouse.position.x
              let y1 = mouse.position.y
              let best_vi = 0
              let min_dist = 1000000000
              for(let i = 0; i < V.length; i++){
                let x2 = V[i].position.x
                let y2 = V[i].position.y
                let dist = Math.sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))
                if(dist < min_dist){
                  min_dist = dist
                  best_vi = i
                }
              }

              V[best_vi].isStatic = !move_ok
              if(move_ok){
                V[best_vi].render.fillStyle = 'white'
                V[best_vi].render.strokeStyle = 'white'
              }else{
                V[best_vi].render.fillStyle = 'red'
                V[best_vi].render.strokeStyle = 'red'
              }
          };
          var score = document.createElement('score');
          score.style.color = 'blue';
          score.style.fontWeight = 'bold';
          score.innerHTML = 'score:';
          let container = document.getElementById('container')
          container.appendChild(score);
          update = function(){
            //score
            let sum = 0
            for(let i = 0; i < holes.length; i++){
              let x1 = holes[i][0]
              let y1 = holes[i][1]
              let min_dist = 123456789123456789
              for(let j = 0; j < V.length; j++){
                let x2 = V[j].position.x
                let y2 = V[j].position.y
                x2 = (x2 - x_origin) / x_scale
                y2 = (y2 - y_origin) / y_scale
                const dist = (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1)
                if(dist < min_dist){
                  min_dist = dist
                }
              }
              sum += min_dist
            }
            score.innerHTML = 'score:' + sum

            //長さの制約
            for(let i = 0; i < E.length; i++){
              let d = dist(E[i].bodyA.position, E[i].bodyB.position)
              let constraint_d = constraint_dists[i]
              let color = 'white'
              let diff = d/constraint_d - 1
              let threshold = eps / 1000000
              if(diff > eps / 1000000){
                color = 'red'
              }else if(diff < eps / 1000000){
                color = 'blue'
              }
              E[i].render.strokeStyle = color
            }
          }
          setInterval(update, 100)
        </script>
    </body>
</html>